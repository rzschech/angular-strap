{"version":3,"sources":["modules/tooltip.js"],"names":["angular","target","provider","placement","this","defaults","template","contentTemplate","trigger","keyboard","html","show","title","type","delay","autoClose","bsEnabled","viewport","selector","padding","$get","String","htmlReplaceRegExp","$body","nodeName","element","toLowerCase","$tooltip","deferred","promise","enterAnimateCallback","scope","$emit","options","prefixEvent","tipElement","display","_tipToHide","_blur","blur","inlineTemplate","css","toggle","$isShown","forEach","triggers","on","unbindTriggerEvents","enter","i","length","leave","off","split","bindKeyboardEvents","$onKeyUp","isTouch","$onFocusElementMouseDown","unbindKeyboardEvents","_autoCloseEventsBinded","bindAutoCloseEvents","$timeout","$onFocusKeyUp","node","hide","event","parentNode","getPosition","$element","el","rect","width","extend","elRect","height","p","top","left","dimensions","offset","scroll","isBody","document","documentElement","$window","getCalculatedOffset","position","actualWidth","actualHeight","outerDims","clientWidth","innerHeight","tip","marginTop","parseInt","using","props","isNaN","right","marginLeft","setOffset","delta","getViewportAdjustedDelta","isVertical","replaceArrow","arrowDelta","test","arrowOffsetPosition","viewportPadding","topEdgeOffset","$viewport","viewportDimensions","leftEdgeOffset","rightEdgeOffset","dimension","isHorizontal","findElement","$arrow","clearTimeout","unbindAutoCloseEvents","timeout","tipScope","safeDigest","$promise","fetchTemplate","$options","config","$scope","$new","$rootScope","$id","attr","map","parseFloat","$sce","trustAsHtml","$setEnabled","$$postDigest","id","$hide","setEnabled","isEnabled","templateEl","contentEl","then","tipLinker","tipTemplate","isObject","init","data","replace","container","tipContainer","bindTriggerEvents","isElement","focus","destroyTipElement","$destroy","hoverState","parent","after","lastChild","visibility","clonedElement","$applyPlacement","addClass","customClass","prepend","$animate","version","minor","$$rAF","leaveAnimateCallback","defaultPrevented","elementPosition","tipWidth","prop","autoToken","tipHeight","autoPlace","originalPlacement","containerPosition","bottom","bottomOverlap","topOverlap","indexOf","rightOverlap","leftOverlap","removeClass","hasClass","tipPosition","applyPlacement","evt","stopPropagation","preventDefault","fetchPromises","cache","$templateCache","res","TooltipFactory","$http","get","directive","restrict","trim","defer","resolve","$location","link","falseValueRegExp","transclusion","dataTarget","key","isDefined","hasOwnProperty","oldValue","tooltip","$observe","newValue","bsTooltip","$watch","bsShow","isString","match","setViewport","$on","destroy"],"mappings":"AAOA,YAEAA,SAGMC,OAAQ,0BAAA,sCAAAC,SAAA,WAAA,WAFZ,GAGIC,GAAWC,KAAAC,UACXC,UAAU,UACVC,YAAAA,GACAC,YAAS,UACTC,YAAU,UACVC,WAAM,EACNC,QAAM,EACNC,UAAO,MACPC,SAAM,2BACNC,iBAAO,EACPC,QAAAA,cACAC,UAAAA,EACAC,MAAAA,EAFFN,MAGGO,EAFHN,MAGGO,GAFHN,KAAM,GACNC,MAAO,EAKPV,WAAKgB,EAEHJ,WAAWK,EACXJ,UACAC,SAAII,OACJH,QAAII,GAFRnB,MASMgB,MAAII,UAAWC,aAAoBC,WAAAA,KAAAA,iBAAAA,QAAAA,WAAAA,OAAAA,aAAAA,QAAAA,WAAAA,SAAAA,EAAAA,EAAAA,EAAAA,EAAAA,EAAAA,EAAAA,EAAAA,EAAAA,EAAAA,EAAAA,GAJvC,QASMC,GAAoBC,EAASC,GAmKjC,QAmFMC,KAlFJC,EAAMC,MAAMC,EAAQC,YAAc,QAASP,GAyC7C,QAyGQQ,KAvGN,GADAJ,EAwGsBK,MAAAA,EAASF,YAAA,QAAAP,GAvG3BQ,IAuG2CE,EAAA,CAtG7C,GAAIC,GAA6B,UAApBL,EAAQzB,QACnB,MAAOiB,GAAQ,GAAGc,MAEhBN,GAAQO,gBACVL,EAAWM,KA0Gfd,QAASe,GACPf,WAASgB,KAITR,KAJJ,QAoJQV,KAnJN,GAoJMD,GAAAA,EAAahB,QAAYA,MAAAA,IAnJ/BR,SAAQ4C,QAAQC,EAAU,SAASrC,GACjB,UAAZA,EACFiB,EAAQqB,GAAG,QAASnB,EAASe,QAsJxBK,WAAAA,IACHF,EAAAA,GAAmBrC,UAARyB,EAAsB,aAAA,QAAAN,EAAAqB,OACrCvB,EAASwB,GAAaC,UAATL,EAAuB,aAAA,OAAAlB,EAAAwB,OACpBN,WAAdrB,GAAuByB,UAAAA,GAAAA,EAAAA,GAAAA,EAAAA,aAAAA,YAAAA,EAAAA,6BAjJ7B,QAqJQxB,KAnJN,IAqJMD,GADAC,GAAQ2B,EAAI5C,QAAY6C,MAAA,KACxB7B,EAAAA,EAAa0B,OAAY1C,KAAAA,CApJ7B,GAAIA,GAAUqC,EAASI,EACP,WAAZzC,EACFiB,EAAQ2B,IAAI,QAASzB,EAASe,QAuJzBY,WAAAA,IACJrB,EAAQzB,IAAY,UAAZA,EAAqB,aAAA,QAAAmB,EAAAqB,OAC9Bb,EAAAA,IAAuBR,UAATnB,EAAkB+C,aAAAA,OAAAA,EAAAA,OAC3B,WAtJL/B,GAsJK,UAAAhB,GAAAiB,EAAA2B,IAAAI,EAAA,aAAA,YAAA7B,EAAA8B,4BAKT,QAASC,KACgB,UAApBzB,EAAQzB,QACT2B,EAAWiB,GAAAA,QAAIzB,EAASA,UAExBF,EAAQ2B,GAAAA,QAAIzB,EAASA,eAIzB,QAAIgC,KACKC,UAAT3B,EAAS2B,QAGPC,EAAST,IAAA,QAAAzB,EAAA4B,UAIPI,EAAAA,IAAAA,QAAAA,EAAyBG,eAxJ/B,QA6JQH,KA5JNE,EA6JUT,WACNO,EAAAA,GAAAA,QAAAA,GA5JFA,GAAyB,GACxB,GAAG,GAER,QA8JQI,KACJJ,IACEpC,EAAIwC,IAAAA,QAAS5B,GA7JfwB,GA8JI,GA3JR,QA8JQhC,GAASqC,GA5Jf,IADA,GA8JMD,GAAAE,EAAAhE,OA7JC8D,GAAM,CA+JTA,GAAAA,IAAYG,EAAAA,GA7JZ,MAmKJ,IAAAH,IAASI,EAAYC,GAGfC,WAFJD,GAAWA,MAMXL,GAAIO,EAAAA,YAjKR,QAASH,GAAYC,GA0KjBA,EAASG,GAAUtC,EAAMhC,QAAAwB,CAxK3B,IA0KI6C,GAAOtE,EAAQwE,GAAAA,EAAWF,SAAAA,EAAAA,QAAQC,EAAOE,EAAAA,wBAA4BC,IAvKzE,KAAK,GAAIC,KAAKF,GACZH,EAAKK,GAAKF,EAAOE,EAwKc,QAALC,EAAKL,QAAGM,EAAM7E,QAAAwE,UAAAF,GAAMQ,MAAAA,EAAWC,MAAOV,EAC5DW,KAAWA,OAASC,EAASC,OAASC,EAAAA,MAjK5C,IAkK0ET,GAAQU,GAjKhFR,IAiKwG,EAExGC,KAAO7E,GAjKL8E,EAAWC,OAAOV,GAAKW,GAoK3BA,OAASK,EAAAA,SAAoBlF,gBAAWmF,WAAUC,SAAaC,KAAAA,UAAAA,EAAAA,KAAAA,cAAAA,GAC7DC,EAAIV,GACJR,MAAIlB,SAAQlD,gBAAgBuF,YAE5BhB,OAAQrB,EAAMsC,aACd,IAnKF,OAoKIZ,SAAAA,UAAAA,EAAAA,EAAAA,EAAAA,GAlKN,QAoKQF,GAAsBS,EAASf,EAAAA,EAAAA,GAnKrC,GAAIQ,GAqKA1B,EAAAlD,EAAAkD,MAAA,IAnKJ,QAAQA,EAAM,IAoKZ,IAAK,QACH0B,GACEH,IAAKU,EAASV,IAAMU,EAASZ,OAAAA,EAAAA,EAAAA,EAC7BG,KAAMS,EAAST,KAAOS,EAASf,MAEjC,MACF,KAAK,SACHQ,GACEH,IAAKU,EAASV,IAAMU,EAASZ,OAC7BG,KAAMS,EAAST,KAAOU,EAAAA,MAAAA,EAAAA,EAAAA,EAExB,MACF,KAAA,OACER,GACEH,IAAKU,EAASV,IAAMY,EAAAA,OAAAA,EAAAA,EAAAA,EACpBX,KAAMS,EAAST,KAAOS,EAExB,MAGF,SACEP,GAjKAH,IAAKU,EAASV,IAAMY,EAqKnBnC,KAAMiC,EAAOT,KAASxB,EAAMkB,MAAO,EAAAgB,EAAU,GAhKlD,IAoKMlC,EAAA,GAnKJ,MAAO0B,EAET,IAmKaF,QAAPE,EAAAA,IAA+BO,WAAhBA,EAAST,GAlK5B,OAAQxB,EAAM,IACb,IAmKM,OACL0B,EAAQ1B,KAAMiC,EAAAT,IACd,MAjKD,KAmKG,QAlKFE,EAAOF,KAAOS,EAAST,KAAOS,EAASf,MAAQgB,MAoK7CR,IAAaO,SAANV,EAAMU,IAAwBZ,UAATY,EAAAA,GAjKhC,OAAQjC,EAAM,IACb,IAAK,MAoKN0B,EAAOA,IAAAA,EAAAA,IAAAA,CAlKL,MAsKF,KAAIa,SAKAC,EAAAA,IAAYC,EAAShB,IAAAA,EAAec,OAOxCb,MAAOH,GA1KX,QA+KIE,GAAqBc,EAAK5F,GA9K5B,GA+KI+F,GAAO5D,EAAU6D,GAAAA,EAAAA,EAAAA,YAAAA,EAAAA,EAAAA,aACf7D,EAAWM,SAAAA,EAAAA,IAAAA,EAAAA,cAAAA,IAAAA,EAAAA,SAAAA,EAAAA,IAAAA,EAAAA,eAAAA,GA9KbwD,OA+KIrB,KAAgBoB,EAAMpB,GA9K1BqB,MA+KIpB,KAAiBmB,EAAMnB,GA9K/BE,EA+KQmB,IAAOnB,EAAAH,IAAAiB,EA9Kfd,EAAOF,KAAOE,EAAOF,KAAOsB,EAC5BrB,EAAWsB,UAAUR,EAAK5F,QAAQwE,QAChCuB,MA+KGhB,SAASiB,GAGRT,EAAAA,KAGApF,IAAAA,KAAAA,MAAc6F,EAASR,KAAAA,KACzBT,KAAOH,KAAMG,MAAOH,EAAMF,MAASc,KAlLjCU,MAAO,OA2LXnB,GAAUF,EAvLZ,IAwLIE,GAAesB,EAAAA,YAAMxB,EAAAA,EAAAA,YAKvBC,IAJO,QAxLL3E,GAwLKqF,IAAAd,IACLK,EAAOH,IAAAA,EAAaA,IAAAA,EAAAA,IAGtBE,8CAA0BC,KAAAA,GAA1BD,CAEA,GAAIuB,GAAAC,EAA6BnG,EAAY4E,EAAAQ,EAAAC,EAnL/C,IAoLIa,EAAIE,KAIJC,EAAAA,MAAaC,EAAAA,KA3Lf1B,EAAOH,KAAOyB,EAAMzB,IAgMpBE,EAAIuB,UAAAA,EAAAA,GAAUzB,wBAAK8B,KAAAvG,GAAA,CAAG0E,GAAAA,GAAM,aAAA6B,KAAAvG,GAAAsG,EAAAF,EAAA,EAAAF,EAAAxB,KAAAN,EAAAgB,EAAA,EAAAc,EAAAzB,IAAAF,EAAAc,EAAAmB,EAAAJ,EAAA,cAAA,cA3L5BC,GA4LgBvE,EAAQhB,EAAAA,GAAwBgB,KAzLpD,QAASqE,GAAyBnG,EAAWmF,EAAUC,EAAaC,GA+LhE,GAAIoB,IAGJhC,IAAI,EACFC,KAAIgC,GAEJC,EAAID,EAAgBE,UAAAA,EAAwB9E,EAAAhB,SAAAC,UAAAe,EAAAhB,SAhMhD,KAiMMoF,EAhMJ,MAiMSA,EA/LX,IAAIO,GAAkB3E,EAAQhB,UAAYgB,EAAQhB,SAASE,SAAW,EAAG4F,EAAqB5C,EAAY2C,EAC1G,IAAI,aAiMKJ,KAAAvG,GAAA,CACL,GAAI6G,GAAAA,EAAkB1B,IAAST,EAAO+B,EAChBtB,OAAAA,EAAgBsB,EAAkBrB,IAAAA,EAAAA,EAAAA,OAAAA,CACpDyB,GAAAA,EAAiBD,IACnBV,EAAMxB,IAAAA,EAAOkC,IAAmBlC,EACvBoC,EAAkBF,EAAmBxC,IAAOwC,EAAArC,SACrD2B,EAAMxB,IAAAA,EAAOkC,IAAmBlC,EAAOkC,OAAmBxC,OAhMzD,CAoML,GAAAyC,GAAOX,EAAAA,KAAAA,EAAAA,EAAAA,EAAAA,KAAAA,EAAAA,CAlMHW,GAAiBD,EAAmBlC,KAqM1CwB,EAASG,KAAAA,EAAoBU,KAAWC,EACzBC,EAAYL,EAAAxC,QAEzB8C,EAAO5E,KAAI0E,EAAwBtC,KAAOkC,EAAkBG,MAAAA,GAM5DI,MAAAA,GAtMJ,QAyMSrF,GAAQlB,EAAWmG,EAAAC,GAxM1B,GAyMMI,GAAAA,EAAAA,yBAAAA,EAAAA,GAxMNF,GAAO5E,IAAI0E,EAAe,OAAS,MAAO,IAAM,EAAId,EAAQa,GAAa,KAAKzE,IAAI0E,EAAe,MAAQ,OAAQ,IAEnH,QA0MQzD,KAzMN4D,aAAaE,GACT7F,EAASgB,UAA2B,OAAfR,IA4MpBsF,EAAU1G,WACX0G,IAzMExF,EAAQxB,UA6MT0B,KAzMDsF,IA6MAtF,EAAAA,WA3MFsF,EAAW,MA+MbtF,IA5MOF,EAAQO,gBAkNjBL,EAASuF,SA/MLvF,EAAaR,EAASyC,SAAW,MA1iBrC,GAAIzC,MAWAA,EAASgG,EAAWC,GAAAA,SAAAA,cATpB3F,EAAUN,EAASkG,SAAW7H,QAAQwE,UAAWnE,EAAUyH,EAY7D,IAAI/F,EAAQJ,eAASoG,CACrB,GAAG9F,GAAQnB,EAAAA,OACTc,GAAIyB,UACJpB,EAAQnB,SAAQuC,EAAMH,YATxBvB,GAS4D0B,SAAMuE,EAAA3F,EAAA3B,SAPpE,IAAIyB,GAAQJ,EAASoG,OAAS9F,EAAQF,OAASE,EAAQF,MAAMiG,QAAUC,EAAWD,MAahFrG,IAAAA,EAASuG,OAAMjG,QAAcR,SAAQ0G,EAAKrH,OAAS,CAGnD,GAAGmB,GAAQrB,EAAOE,MAAAuC,MAAA,KAAA+E,IAAAC,WAChBtG,GAAMnB,MAAQ0H,EAAKC,OAAYtG,GAb/BtB,KAAM0C,EAAM,GAiBdtB,KAAMyG,EAAAA,IACJzG,EAAM0G,GAdV9G,EAASuG,IAAMjG,EAAQyG,IAAMjH,EAAQ0G,KAAK,OAAS,GAC/ClG,EAAQrB,QAiBVmB,EAAM4G,MAAQL,EAAAC,YAAAtG,EAAArB,QAdhBmB,EAgBMJ,YAASqC,SAAAA,GAfbjC,EAAM0G,aAAa,WACjB9G,EAASiH,WAAWC,MAGxB9G,EAgBMJ,MAAShB,WAfboB,EAAM0G,aAAa,WACjB9G,EAASqC,UAGbjC,EAgBMJ,MAASe,WAfbX,EAAM0G,aAAa,WACjB9G,EAAShB,UAwBXoB,EAAGE,QAAQ1B,WACToB,EAAAA,aAASgG,WACPhG,EAAImH,YAlBVnH,EAsBQgB,SAAIoG,EAAU7F,UAAQ6F,CArB9B,IAAIvB,GAsBIuB,CArBJ9G,GAsBI1B,kBArBNoB,EAASgG,SAAWhG,EAASgG,SAASqB,KAAK,SAAS1I,GAClD,GAAIwI,GAAa9I,QAAQyB,QAAQnB,EACjC,OAAOsH,GAAc3F,EAAQ1B,iBAAiByI,KAAK,SAASzI,GAyB1D0I,GAAAA,GAAW9G,EAAY+G,sBAA2BzB,EAAAA,GAGlD,OAFKE,GAASqB,SAAKD,EAASzI,EAAAA,oBAAAA,EAAAA,KAC9ByI,EAAYvG,WAAAA,WAAgB9B,KAAAH,GACvBP,EAAQmJ,GAAS7I,cApB1B,IAwBM2I,GAAAA,EAAqB3I,EAAAA,EAAAA,CAvB3BqB,GAASgG,SAASqB,KAAK,SAAS1I,GAyB5BqB,EAASyH,iBAvBLpJ,QAAQmJ,SAAS7I,KAAWA,EAAWA,EAAS+I,MA0BtD1H,EAAgBjB,OAAAJ,EAAAA,EAAAgJ,QAAAhI,EAAA,mBAGdhB,EAAYQ,EAAAA,MAASd,GACnBiC,EAAQnB,EA1BVmI,EA2BUhH,EAAQnB,IAzBpBa,EAASyH,SAEXzH,EAkCOM,KAAQsH,WACTC,EAAAA,OAAe/H,QAAAA,SAAAA,EAAAA,SAjCjBQ,EAkCOnB,OACL0I,KAAAA,EAAevH,MAjCf+B,KAkCK/B,EAAGA,QAKVwH,SAAAA,EAAAA,UAGAD,EAAWvJ,EACDA,QAASD,UAAQ0J,EAAUzH,WArCrCuH,EAAevH,EAAQsH,UAyCpBtH,EAAQO,YACTP,EAAQO,EAAiBxC,EAAQ0J,YAInCD,IACE1H,EAAM0G,SAzCRxG,EA0CIA,OAAQzB,QAAYkJ,UAAUjI,EAAWkI,QAAUhI,EAAAA,OAAShB,EAAAA,EAAAA,SAxC9DsB,EAAQO,iBACVP,EAAQO,eAAiBxC,QAAQ0J,UAAUzH,EAAQO,gBAAkBP,EAAQO,eAAiB4E,EAAYnF,EAAQO,eAAgBP,EAAQhC,QAAUgC,EAAQhC,OAAO,KAgDnK8C,EAAAA,MAGA6G,EAAAA,aAAAA,WAGMC,UAAN9H,EAAM8H,QAAAA,EAAAA,GAAAA,QAAAA,EAAAA,UA9CVlI,EAqDImI,QAAa,WACb/G,IApDF6G,IACA7H,EAAM8H,YAERlI,EAsDUmI,MAAAA,WAKRnI,MA1DA2F,cAsDaxG,GArDbgJ,EAAa,KAyDbnI,EAAShB,OAAOsB,EAAAnB,MAAAH,UAId6G,EAAIuC,WAAQC,WAEAxH,OAARP,GAAQO,EAAgB7B,QAC1BwB,EAAAA,MAAaR,OANVM,EAAQjB,QAlDjBW,EA2DUM,KAAQsH,WA1DhB,GA2DMQ,EAASP,YAAAA,EAAAA,SA3Df,CACAzH,EA2DMC,MAAIwH,EAAAA,YAAgBS,eAAWtI,EA1DrC,IAAIoI,GA2DIC,CA1DJ/H,GA2DSO,eA1DXL,EA2DcR,EAAAyC,SAAAnC,EAAAO,gBAzDVP,EA2DKsH,WACLQ,EAASP,EAzDTQ,EA0DAA,EAAQvI,GAAAA,UA1DAzB,QAAQyB,QAAQ+H,EAAa,GAAGS,WAiE/BtI,OAKKiD,EAAK,KAAWC,EAAMpD,GAA0BW,GAASwH,IA7D3EnC,EA6DoFyC,EAAYnC,OAAAC,OA5DhG7F,EAAaR,EAASyC,SAAW6E,EAAUxB,EAAU,SAAS0C,EAAepI,MAC7EI,EAAWM,KA+DRR,IAAAA,UAEAA,KAAAA,UAEAA,MAAAA,OAEHG,QAAaI,QAIXwH,WAAcA,YAIhBtC,EAAW3F,WAAAA,EAAAA,SAAAA,EAAAA,WAGXJ,EAASyI,MAAAA,EAAAA,SAAAA,EAAAA,YAAAA,IAAAA,EAAAA,MAELnI,EAAQO,aAAAA,EAAgB6H,SAAApI,EAAAqI,aAC1BxI,EAAAA,iBAvEFkI,EAyEKA,EAAAA,MAAA7H,GAAA4H,EAAAQ,QAAApI,IAvEPR,EA4EM6I,SAAerI,EAAAA,UAAY4H,EA3EjCrC,EA4EW3F,GA3EXJ,EA4EM6I,kBA3EFvI,EAAQO,eACVV,IA+EM9B,QAAAyK,QAAAC,OAAA,EAEJF,EAAGrI,MAAYA,EAAWM,EAAAA,EAAAA,GA5E1B+H,EAASxH,MAAMb,EAAY4H,EAAQC,GAAOhB,KAAKlH,GAGnD4F,EA8EOzF,GA7EP0I,EA8EMhJ,WA7EAQ,GAAYA,EAAWM,KA+EzBa,WAAAA,cAIAM,EAAAA,WA9EsB,UAApB3B,EAAQzB,SACVmB,EAASgI,QAmFX5H,KAGFJ,EAASwB,WAEPmE,MA7EJ3F,EAmFUmI,MAAAA,WAhFR,MAFAxC,cAmFetD,GAlFf8F,EAAa,MAoFR7H,EAAQnB,OAAMkD,EAAAA,MAAAA,UAKnBwD,EAAInF,WAAAA,WACY,QAAhBV,GAEEA,EAAIA,QAEFM,EAAAnB,MAAAkD,OA5FKrC,EAASqC,OAQpB,IAwFI1B,GAIAD,CA1FJV,GA4FOM,KAAQO,SAAAA,GACToI,EAAAA,WA3FA7I,EA6FGC,MAAAC,EAAAC,YAAA,eAAAP,GAAAkJ,mBA1FPvI,EAAQC,EACRF,EA+Fec,EA9FXlB,EAAQO,eACVoI,IAkGAlD,QAAW3F,QAAAA,OAAAA,EAGRE,EAAQxB,MAAAA,EAAY0B,GAhGrBqI,EAASrH,MAAMhB,GAAY6G,KAAK4B,GAGpCjJ,EAASgB,SAAWZ,EAAMY,UAAW,EACrC+E,EAAW3F,GAqGXE,EAAS2I,UAAAA,OAAAA,GACP7I,IAMEE,EAAGK,WAA6B,OAAZ9B,GAvGtB+G,OAkBJ5F,EA2GIM,OAAQjB,WA1GVW,EAASgB,SAAWhB,EAASwB,QAAUxB,EAASqB,SAElDrB,EA4GIM,MAAQhB,WA3GVkB,EAAW,GAAGwH,SAEhBhI,EA+GQQ,WAAY,SAAA0G,GAGhB5G,EAAI9B,UAAY8B,GA/GpBN,EAoHMxB,YAAYA,SAAUmJ,GAnH1BrH,EAAQhB,SAAWA,GAErBU,EAuHMQ,gBAAoBF,WAtHxB,GAAKE,EAAL,CA2HE,GAAI2I,GAAAA,EAAkB3G,UAAAA,EAClB4G,eAAsBC,EAAKC,EAC3BC,KAAAA,EAGAC,KACFhL,EAAIiL,EAAAA,QAAoBjL,EAAAA,KAAAA,EAAAA,WAExB8B,EAAIoJ,gBAGJlJ,EAAImJ,SAASF,EAAAA,UA9HjB,IAiIIN,GAAmB3G,IAAA4G,EAAA5I,EAAA6I,KAAA,eAAAE,EAAA/I,EAAA6I,KAAA,eAhIvB,IAiIMG,EAAII,CAhIR,GAiIIH,GAAiBC,EACjB9B,EAAcgC,EAAAA,UAAgBnE,EAAYoE,EAAAA,WAAgB/J,EAAAsI,SACxDsB,EAAoBG,EAAYjC,GAhIlC+B,EAiIQ1G,EAAK6G,QAAA,WAAA,EAhIb7G,EAiIMzE,EAAYiL,QAAAA,QAA0B,CAhIhD,IAAIE,GAAU1G,EAAK,CACjB,GAAI2G,GAkIKT,EAAAQ,OAAAD,EAAAC,OAAAJ,EACHM,EAAYH,EAAAzG,IAAAkG,EAAAlG,IAAAsG,GAjIdI,GAkIInL,EAAYiL,GAAAA,GAAkB9B,EAAkB,KAjIlCkC,EAAhBD,EACE3G,IACFzE,EAAYiL,EAAkB9B,QAAQ,MAAO,WAyI/CzE,IACAqB,EAAekF,EAAA9B,QAAA,SAAA,SAjIrB,GAAIpD,GAsIc,UAANrB,GAAM,gBAAAuG,GAAA,aAAAA,EArIdvG,EAsIkBuG,SAAZjL,GAAqDA,iBAAnBiL,GAA8C,cAATA,CArIjF,IAAIlF,GAASrB,EAAM,CACjB,GAAI6G,GAuIKZ,EAAA5E,MAAAmF,EAAAnF,MAAA6E,EACHY,EAAWN,EAAAxG,KAAAiG,EAAAjG,KAAAkG,GAtIb7E,GAuII/F,EAAYiL,GAAAA,GAAsBO,EAAU,KAtI/BA,EAAfD,EACE7G,IACF1E,EAAkC,SAAtBiL,EAA+B,QAAUjL,EAAUmJ,QAAQ,QAAS,SA2IpFnH,IAvIIhC,EAAkC,UAAtBiL,EAAgC,OAASjL,EAAUmJ,QAAQ,OAAQ,WAKlFrH,EA0IEO,gBACHP,EAAQhC,YAAO2L,yBAA+BvB,SAAAlK,GAvIpD,GA2IM8B,EAAI9B,SAAUsL,EAAQxL,OAAW4L,SAAG,aAAA5J,EAAAhC,OAAA4L,SAAA,WAClC1J,EAAAA,QAAWyJ,QAAY,EA1I3B3J,EA4IOhC,OAAA2L,YAAA,YAAAvB,SAAA,UA1IPpI,EAAQhC,OAAO2L,YAAY,UAAUvB,SAAS,YAE5ClI,EA6IC0J,SAAA,mBAECC,EAAAA,QAAczG,SAAAA,EAClB0G,EAAeD,YAAAA,uBA5Ib3J,EAAWkI,SAAS,4BAkJtB1I,CACAqK,GAAIC,GAAAA,EAAAA,EAAAA,EAAAA,EAAAA,EA9INF,GAAeD,EAAa3L,MAGhCwB,EAgJQqK,SAAc,SAAIA,GACTzJ,KAAXd,EAAAA,OAAWc,EAAAA,WACXyJ,EAAIC,OA/IND,EAAIC,oBAGRtK,EAiJQuK,cAAAA,SAAAA,GACAD,KAAAA,EAAAA,QAEJtK,EAASgB,GAAAA,OAjJTqJ,EAAIC,oBAGRtK,EAoJI3B,yBAA0B,SAASQ,GAnJrCwL,EAoJIE,iBAnJJF,EAoJMvK,kBAnJNE,EAoJWgB,SAAGnC,EAAY,GAAA+B,OAAUd,EAAA,GAAAkI,QAkDpC,IAAAhG,IAAS4D,CAkCX,OAAO5F,GAqNP,QAASiG,GAAAA,GACP7F,EAAGoK,SAAAA,EAAc7L,OAAWyB,EAAOoK,MAAAA,SAAc7L,EAAAA,UAjNrD,QAkN2D8L,GAAOC,EAAAA,GAjNhE,MAiNiFrD,SAAKvH,SAAS6K,GAAAA,UAAAA,iBAAAA,IA9MjG,QAAS1E,GAActH,GAmNrB,MAAA6L,GAAOI,GAAAA,EAAAA,GAjNAJ,EAAc7L,GAAYkM,EAAMC,IAAInM,GAuN9CoM,MAAUL,IAETrD,KAAA,SAAAsD,GACEK,MAAUL,GAAAjD,OAvxBZ,GASIuD,GAAI3K,OAAUN,UAASkG,KACvBrE,EAAWhB,eAAgB4C,GAAAF,SACzB5D,EAAkBuL,cAClBjL,EAAAA,QAASkL,QAAAA,EAAAA,UA8iBXX,IASJ,OAyNQlK,OAvNTyK,UAAU,aAAe,UAAW,YAAa,OAAQ,WAAY,QAAS,SAAStH,EAAS2H,EAAWzE,EAAM3G,EAAUgJ,GAC5H,OACEgC,SAuNS3M,MAtNT+B,OAAO,EACPiL,KAyNQC,SAAAA,EAAmBxL,EAAA0G,EAAA+E,GACvBlN,GAAAA,IACE+B,MAAG/B,EAKLA,SAAImN,SAAa1L,WAAa,kBAAA,YAAA,YAAA,QAAA,UAAA,OAAA,YAAA,oBAAA,OAAA,cAAA,MAAA,SAAA2L,GAC3BpN,QAAQqN,UAAUF,EAAAA,MAAalL,EAAAmL,GAAAjF,EAAAiF,KA1NpC,IAAIH,GAAmB,eAmOrBjN,SAAK+B,SAAMuL,OAAe,aAAS,SAAAF,GACjCrL,QAAMnB,UAAQuH,EAAAiF,KAAAH,EAAAvG,KAAAyB,EAAAiF,MAAAnL,EAAAmL,IAAA,IAIhBjF,IAAAA,GAAc1G,EAAS0G,KAAA,cACrBnI,SAAIA,UAAQqN,KACWzM,EAAAA,OAArBqM,EAAelL,KAAMnB,IAAAA,EAAAA,GAErBZ,EAAAA,eAAkBuN,WAnOtBxL,EAoOMyL,MAAAA,IAlORrF,EAAKsF,SAAS,QAAS,SAASC,GAC9B,GAAI1N,QAAQqN,UAAUK,KAAc3L,EAAMuL,eAAe,SAAU,CAuOnEnF,GAAKwF,GAAa5L,EAAM6L,KACtB7L,GAAG/B,MAAQmJ,EAASuE,YAAWA,GAC7B1N,QAAQwE,UAAOzC,IAAO2L,EAAAA,WArOtBF,GAsOKA,EAAApD,uBAlOXjC,EAsOMqF,WAAWA,EAAQpD,OAAAA,EAAAA,UAAAA,SAAAA,EAAAA,GArOnBpK,QAAQmJ,SAASuE,GAuOlB1N,QAAAwE,OAAAzC,EAAA2L,GAID3L,EAAIyL,MAAAA,EAEJE,QAAAA,UAAaH,IAAe5M,EAAS6M,WAvOrCA,GAAWA,EAAQpD,sBA6OnB,GA1OJjC,EA2OI0F,QAAWC,EAAAA,OAASJ,EAAAA,OAAWA,SAAaA,EAASK,GACrDL,GAAa1N,QAAQwN,UAAQ5E,KA1O3B5I,QAAQ8N,SAASJ,KAAWA,IAAaA,EAASK,MAAM,wBA8O5D5F,KAAKlH,EAAYc,EAAaoG,OAAKlH,EAAU+C,UA3O/CmE,EA6OIqF,WAAQQ,EAAYN,OAAAA,EAAAA,UAAAA,SAAAA,EAAAA,GA5OjBF,GAAYxN,QAAQqN,UAAUK,KAgP/BF,QAAU7L,SAASF,KAASQ,IAAAA,EAAAA,MAAAA,0BAGVuL,EAAA5E,WAAtB7G,KAAU,GAAY,GAAA,MA/OxBoG,EAiPIlG,UAAUF,EAAA6L,OAAAzF,EAAAlH,SAAA,SAAAyM,GACVF,GAAUxN,QAAAqN,UAAAK,IAhPZF,EAAQQ,YAAYN,IAEtB,IAAIF,GAAU7L,EAASF,EAASQ,EAChCF,GAAMkM,IAAI,WAAY,WAChBT,GAASA,EAAQU,UACrBjM,EAAU,KACVuL,EAAU","file":"modules/tooltip.min.js","sourcesContent":["'use strict';\n\nangular.module('mgcrea.ngStrap.tooltip', ['mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$tooltip', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      customClass: '',\n      prefixClass: 'tooltip',\n      prefixEvent: 'tooltip',\n      container: false,\n      target: false,\n      placement: 'top',\n      template: 'tooltip/tooltip.tpl.html',\n      contentTemplate: false,\n      trigger: 'hover focus',\n      keyboard: false,\n      html: false,\n      show: false,\n      title: '',\n      type: '',\n      delay: 0,\n      autoClose: false,\n      bsEnabled: true,\n      viewport: {\n       selector: 'body',\n       padding: 0\n      }\n    };\n\n    this.$get = function($window, $rootScope, $compile, $q, $templateCache, $http, $animate, $sce, dimensions, $$rAF, $timeout) {\n\n      var trim = String.prototype.trim;\n      var isTouch = 'createTouch' in $window.document;\n      var htmlReplaceRegExp = /ng-bind=\"/ig;\n      var $body = angular.element($window.document);\n\n      function TooltipFactory(element, config) {\n\n        var $tooltip = {};\n\n        // Common vars\n        var nodeName = element[0].nodeName.toLowerCase();\n        var options = $tooltip.$options = angular.extend({}, defaults, config);\n        if(options.inlineTemplate) {\n          var deferred = $q.defer();\n          deferred.resolve();\n          $tooltip.$promise = deferred.promise;\n        }\n        else {\n          $tooltip.$promise = fetchTemplate(options.template);\n        }\n\n        var scope = $tooltip.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n        if(options.delay && angular.isString(options.delay)) {\n          var split = options.delay.split(',').map(parseFloat);\n          options.delay = split.length > 1 ? {show: split[0], hide: split[1]} : split[0];\n        }\n\n        // store $id to identify the triggering element in events\n        // give priority to options.id, otherwise, try to use\n        // element id if defined\n        $tooltip.$id = options.id || element.attr('id') || '';\n\n        // Support scope as string options\n        if(options.title) {\n          scope.title = $sce.trustAsHtml(options.title);\n        }\n\n        // Provide scope helpers\n        scope.$setEnabled = function(isEnabled) {\n          scope.$$postDigest(function() {\n            $tooltip.setEnabled(isEnabled);\n          });\n        };\n        scope.$hide = function() {\n          scope.$$postDigest(function() {\n            $tooltip.hide();\n          });\n        };\n        scope.$show = function() {\n          scope.$$postDigest(function() {\n            $tooltip.show();\n          });\n        };\n        scope.$toggle = function() {\n          scope.$$postDigest(function() {\n            $tooltip.toggle();\n          });\n        };\n        // Publish isShown as a protected var on scope\n        $tooltip.$isShown = scope.$isShown = false;\n\n        // Private vars\n        var timeout, hoverState;\n\n        // Support contentTemplate option\n        if(options.contentTemplate) {\n          $tooltip.$promise = $tooltip.$promise.then(function(template) {\n            var templateEl = angular.element(template);\n            return fetchTemplate(options.contentTemplate)\n            .then(function(contentTemplate) {\n              var contentEl = findElement('[ng-bind=\"content\"]', templateEl[0]);\n              if(!contentEl.length) contentEl = findElement('[ng-bind=\"title\"]', templateEl[0]);\n              contentEl.removeAttr('ng-bind').html(contentTemplate);\n              return templateEl[0].outerHTML;\n            });\n          });\n        }\n\n        // Fetch, compile then initialize tooltip\n        var tipLinker, tipElement, tipTemplate, tipContainer, tipScope;\n        $tooltip.$promise.then(function(template) {\n          if(!options.inlineTemplate) {\n            if(angular.isObject(template)) template = template.data;\n            if(options.html) template = template.replace(htmlReplaceRegExp, 'ng-bind-html=\"');\n            template = trim.apply(template);\n            tipTemplate = template;\n            tipLinker = $compile(template);\n          }\n          $tooltip.init();\n        });\n\n        $tooltip.init = function() {\n\n          // Options: delay\n          if (options.delay && angular.isNumber(options.delay)) {\n            options.delay = {\n              show: options.delay,\n              hide: options.delay\n            };\n          }\n\n          // Replace trigger on touch devices ?\n          // if(isTouch && options.trigger === defaults.trigger) {\n          //   options.trigger.replace(/hover/g, 'click');\n          // }\n\n          // Options : container\n          if(options.container === 'self') {\n            tipContainer = element;\n          } else if(angular.isElement(options.container)) {\n            tipContainer = options.container;\n          } else if(options.container) {\n            tipContainer = findElement(options.container);\n          }\n\n          // Options: trigger\n          bindTriggerEvents();\n\n          // Options: target\n          if(options.target) {\n            options.target = angular.isElement(options.target) ? options.target : findElement(options.target);\n          }\n\n          // Options: inlineTemplate\n          if(options.inlineTemplate) {\n            options.inlineTemplate = angular.isElement(options.inlineTemplate) ? options.inlineTemplate : findElement(options.inlineTemplate, options.target && options.target[0]);\n          }\n\n          // Options: show\n          if(options.show) {\n            scope.$$postDigest(function() {\n              options.trigger === 'focus' ? element[0].focus() : $tooltip.show();\n            });\n          }\n\n        };\n\n        $tooltip.destroy = function() {\n\n          // Unbind events\n          unbindTriggerEvents();\n\n          // Remove element\n          destroyTipElement();\n\n          // Destroy scope\n          scope.$destroy();\n\n        };\n\n        $tooltip.enter = function() {\n\n          clearTimeout(timeout);\n          hoverState = 'in';\n          if (!options.delay || !options.delay.show) {\n            return $tooltip.show();\n          }\n\n          timeout = setTimeout(function() {\n            if (hoverState ==='in') $tooltip.show();\n          }, options.delay.show);\n\n        };\n\n        $tooltip.show = function() {\n          if (!options.bsEnabled || $tooltip.$isShown) return;\n\n          scope.$emit(options.prefixEvent + '.show.before', $tooltip);\n          var parent, after;\n\n          if (options.inlineTemplate) {\n            tipElement = $tooltip.$element = options.inlineTemplate;\n          }\n          else {\n            if (options.container) {\n              parent = tipContainer;\n              if (tipContainer[0].lastChild) {\n                after = angular.element(tipContainer[0].lastChild);\n              } else {\n                after = null;\n              }\n            } else {\n              parent = null;\n              after = element;\n            }\n\n\n            // Hide any existing tipElement\n            if(tipElement) destroyTipElement();\n            // Fetch a cloned element linked from template\n            tipScope = $tooltip.$scope.$new();\n            tipElement = $tooltip.$element = tipLinker(tipScope, function (clonedElement, scope) {});\n\n            // Set the initial positioning.  Make the tooltip invisible\n            // so IE doesn't try to focus on it off screen.\n            tipElement.css({top: '-9999px', left: '-9999px', right: 'auto', display: 'block', visibility: 'hidden'});\n          }\n\n          // Options: animation\n          if(options.animation) tipElement.addClass(options.animation);\n          // Options: type\n          if(options.type) tipElement.addClass(options.prefixClass + '-' + options.type);\n          // Options: custom classes\n          if(options.customClass) tipElement.addClass(options.customClass);\n\n          if (!options.inlineTemplate) {\n            // Append the element, without any animations.  If we append\n            // using $animate.enter, some of the animations cause the placement\n            // to be off due to the transforms.\n            after ? after.after(tipElement) : parent.prepend(tipElement);\n          }\n\n          $tooltip.$isShown = scope.$isShown = true;\n          safeDigest(scope);\n\n          // Now, apply placement\n          $tooltip.$applyPlacement();\n\n          if (options.inlineTemplate) {\n            enterAnimateCallback();\n          }\n          else {\n            // Once placed, animate it.\n            // Support v1.2+ $animate\n            // https://github.com/angular/angular.js/issues/11713\n            if(angular.version.minor <= 2) {\n              $animate.enter(tipElement, parent, after, enterAnimateCallback);\n            } else {\n              $animate.enter(tipElement, parent, after).then(enterAnimateCallback);\n            }\n          }\n          safeDigest(scope);\n\n          $$rAF(function () {\n            // Once the tooltip is placed and the animation starts, make the tooltip visible\n            if(tipElement) tipElement.css({visibility: 'visible'});\n          });\n\n          // Bind events\n          if(options.keyboard) {\n            if(options.trigger !== 'focus') {\n              $tooltip.focus();\n            }\n            bindKeyboardEvents();\n          }\n\n          if(options.autoClose) {\n            bindAutoCloseEvents();\n          }\n\n        };\n\n        function enterAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.show', $tooltip);\n        }\n\n        $tooltip.leave = function() {\n\n          clearTimeout(timeout);\n          hoverState = 'out';\n          if (!options.delay || !options.delay.hide) {\n            return $tooltip.hide();\n          }\n          timeout = setTimeout(function () {\n            if (hoverState === 'out') {\n              $tooltip.hide();\n            }\n          }, options.delay.hide);\n\n        };\n\n        var _blur;\n        var _tipToHide;\n        $tooltip.hide = function(blur) {\n\n          if(!$tooltip.$isShown) return;\n          if(scope.$emit(options.prefixEvent + '.hide.before', $tooltip).defaultPrevented) {\n            return;\n          }\n\n          // store blur value for leaveAnimateCallback to use\n          _blur = blur;\n\n          // store current tipElement reference to use\n          // in leaveAnimateCallback\n          _tipToHide = tipElement;\n\n          if(options.inlineTemplate) {\n            leaveAnimateCallback();\n          }\n          else {\n            // Support v1.2+ $animate\n            // https://github.com/angular/angular.js/issues/11713\n            if(angular.version.minor <= 2) {\n              $animate.leave(tipElement, leaveAnimateCallback);\n            } else {\n              $animate.leave(tipElement).then(leaveAnimateCallback);\n            }\n          }\n\n          $tooltip.$isShown = scope.$isShown = false;\n          safeDigest(scope);\n\n          // Unbind events\n          if(options.keyboard && tipElement !== null) {\n            unbindKeyboardEvents();\n          }\n\n          if(options.autoClose && tipElement !== null) {\n            unbindAutoCloseEvents();\n          }\n        };\n\n        function leaveAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.hide', $tooltip);\n\n          // check if current tipElement still references\n          // the same element when hide was called\n          if (tipElement === _tipToHide) {\n            // Allow to blur the input when hidden, like when pressing enter key\n            if(_blur && options.trigger === 'focus') {\n              return element[0].blur();\n            }\n\n            if (options.inlineTemplate) {\n              tipElement.css({display: '', visibility: ''});\n            }\n\n            // clean up child scopes\n            destroyTipElement();\n          }\n        }\n\n        $tooltip.toggle = function() {\n          $tooltip.$isShown ? $tooltip.leave() : $tooltip.enter();\n        };\n\n        $tooltip.focus = function() {\n          tipElement[0].focus();\n        };\n\n        $tooltip.setEnabled = function(isEnabled) {\n          options.bsEnabled = isEnabled;\n        };\n\n        $tooltip.setViewport = function(viewport) {\n          options.viewport = viewport;\n        };\n\n        // Protected methods\n\n        $tooltip.$applyPlacement = function() {\n          if(!tipElement) return;\n\n          // Determine if we're doing an auto or normal placement\n          var placement = options.placement,\n              autoToken = /\\s?auto?\\s?/i,\n              autoPlace  = autoToken.test(placement);\n\n          if (autoPlace) {\n            placement = placement.replace(autoToken, '') || defaults.placement;\n          }\n\n          if (!options.inlineTemplate) {\n            // Need to add the position class before we get\n            // the offsets\n            tipElement.addClass(options.placement);\n          }\n\n          // Get the position of the target element\n          // and the height and width of the tooltip so we can center it.\n          var elementPosition = getPosition(),\n              tipWidth = tipElement.prop('offsetWidth'),\n              tipHeight = tipElement.prop('offsetHeight');\n\n          // If we're auto placing, we need to check the positioning\n          if (autoPlace) {\n            var originalPlacement = placement;\n            var container = options.container ? findElement(options.container) : element.parent();\n            var containerPosition = getPosition(container);\n\n            // Determine if the vertical placement\n            var bottom = originalPlacement.indexOf('bottom') >= 0;\n            var top = originalPlacement.indexOf('top') >= 0;\n\n            if (bottom || top) {\n              var bottomOverlap = elementPosition.bottom - containerPosition.bottom + tipHeight;\n              var topOverlap = containerPosition.top - elementPosition.top + tipHeight;\n              if (bottom && bottomOverlap > 0 || top && topOverlap > 0) {\n                if (bottomOverlap < topOverlap) {\n                  if (top) {\n                    placement = originalPlacement.replace('top', 'bottom');\n                  }\n                }\n                else {\n                  if (bottom) {\n                    placement = originalPlacement.replace('bottom', 'top');\n                  }\n                }\n              }\n            }\n\n            // Determine the horizontal placement\n            // The exotic placements of left and right are opposite of the standard placements.  Their arrows are put on the left/right\n            // and flow in the opposite direction of their placement.\n            var right = originalPlacement === 'right' || originalPlacement === 'bottom-left' || originalPlacement === 'top-left';\n            var left = originalPlacement === 'left' || originalPlacement === 'bottom-right' || originalPlacement === 'top-right';\n            if (right || left) {\n              var rightOverlap = elementPosition.right - containerPosition.right + tipWidth;\n              var leftOverlap = containerPosition.left - elementPosition.left + tipWidth;\n              if (right && rightOverlap > 0 || left && leftOverlap > 0) {\n                if (rightOverlap < leftOverlap) {\n                  if (left) {\n                    placement = originalPlacement === 'left' ? 'right' : placement.replace('right', 'left');\n                  }\n                }\n                else {\n                  if (right) {\n                    placement = originalPlacement === 'right' ? 'left' : placement.replace('left', 'right');\n                  }\n                }\n              }\n            }\n\n            if (!options.inlineTemplate) {\n              tipElement.removeClass('top left bottom right').addClass(placement);\n            }\n          }\n\n          if (options.target && (options.target.hasClass('dropdown') || options.target.hasClass('dropup'))) {\n            if (placement.indexOf('top') >= 0) {\n              options.target.removeClass('dropdown').addClass('dropup');\n            }\n            else {\n              options.target.removeClass('dropup').addClass('dropdown');\n            }\n\n            if (tipElement.hasClass('dropdown-menu')) {\n              if (placement.indexOf('left') >= 0) {\n                tipElement.removeClass('dropdown-menu-right');\n              }\n              else {\n                tipElement.addClass('dropdown-menu-right');\n              }\n            }\n          }\n          else {\n            // Get the tooltip's top and left coordinates to center it with this directive.\n            var tipPosition = getCalculatedOffset(placement, elementPosition, tipWidth, tipHeight);\n            applyPlacement(tipPosition, placement);\n          }\n        };\n\n        $tooltip.$onKeyUp = function(evt) {\n          if (evt.which === 27 && $tooltip.$isShown) {\n            $tooltip.hide();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusKeyUp = function(evt) {\n          if (evt.which === 27) {\n            element[0].blur();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusElementMouseDown = function(evt) {\n          evt.preventDefault();\n          evt.stopPropagation();\n          // Some browsers do not auto-focus buttons (eg. Safari)\n          $tooltip.$isShown ? element[0].blur() : element[0].focus();\n        };\n\n        // bind/unbind events\n        function bindTriggerEvents() {\n          var triggers = options.trigger.split(' ');\n          angular.forEach(triggers, function(trigger) {\n            if(trigger === 'click') {\n              element.on('click', $tooltip.toggle);\n            } else if(trigger !== 'manual') {\n              element.on(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.on(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              nodeName === 'button' && trigger !== 'hover' && element.on(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n            }\n          });\n        }\n\n        function unbindTriggerEvents() {\n          var triggers = options.trigger.split(' ');\n          for (var i = triggers.length; i--;) {\n            var trigger = triggers[i];\n            if(trigger === 'click') {\n              element.off('click', $tooltip.toggle);\n            } else if(trigger !== 'manual') {\n              element.off(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.off(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              nodeName === 'button' && trigger !== 'hover' && element.off(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n            }\n          }\n        }\n\n        function bindKeyboardEvents() {\n          if(options.trigger !== 'focus') {\n            tipElement.on('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.on('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        function unbindKeyboardEvents() {\n          if(options.trigger !== 'focus') {\n            tipElement.off('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.off('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        var _autoCloseEventsBinded = false;\n        function bindAutoCloseEvents() {\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function() {\n            // Hide when clicking outside tooltip\n            $body.on('click', hideIfNotChildEvent);\n\n            _autoCloseEventsBinded = true;\n          }, 0, false);\n        }\n\n        function unbindAutoCloseEvents() {\n          if (_autoCloseEventsBinded) {\n            $body.off('click', hideIfNotChildEvent);\n            _autoCloseEventsBinded = false;\n          }\n        }\n\n        function hideIfNotChildEvent(event) {\n          var node = event.target;\n          while (node) {\n            if (node === tipElement[0]) {\n              return;\n            }\n            if (node === $body[0]) {\n              $tooltip.hide();\n              return;\n            }\n            node = node.parentNode;\n          }\n        }\n\n        // Private methods\n\n        function getPosition($element) {\n          $element = $element || (options.target || element);\n\n          var el = $element[0],\n              isBody = el.tagName === 'BODY';\n\n          var elRect = el.getBoundingClientRect();\n          var rect = {};\n\n          // IE8 has issues with angular.extend and using elRect directly.\n          // By coping the values of elRect into a new object, we can continue to use extend\n          for (var p in elRect) {\n            // DO NOT use hasOwnProperty when inspecting the return of getBoundingClientRect.\n            rect[p] = elRect[p];\n          }\n\n          if (rect.width === null) {\n            // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\n            rect = angular.extend({}, rect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top });\n          }\n          var elOffset = isBody ? { top: 0, left: 0 } : dimensions.offset(el),\n              scroll = { scroll:  isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.prop('scrollTop') || 0 },\n              outerDims = isBody ? { width: document.documentElement.clientWidth, height: $window.innerHeight } : null;\n\n          return angular.extend({}, rect, scroll, outerDims, elOffset);\n        }\n\n        function getCalculatedOffset(placement, position, actualWidth, actualHeight) {\n          var offset;\n          var split = placement.split('-');\n\n          switch (split[0]) {\n          case 'right':\n            offset = {\n              top: position.top + position.height / 2 - actualHeight / 2,\n              left: position.left + position.width\n            };\n            break;\n          case 'bottom':\n            offset = {\n              top: position.top + position.height,\n              left: position.left + position.width / 2 - actualWidth / 2\n            };\n            break;\n          case 'left':\n            offset = {\n              top: position.top + position.height / 2 - actualHeight / 2,\n              left: position.left - actualWidth\n            };\n            break;\n          default:\n            offset = {\n              top: position.top - actualHeight,\n              left: position.left + position.width / 2 - actualWidth / 2\n            };\n            break;\n          }\n\n          if(!split[1]) {\n            return offset;\n          }\n\n          // Add support for corners @todo css\n          if(split[0] === 'top' || split[0] === 'bottom') {\n            switch (split[1]) {\n            case 'left':\n              offset.left = position.left;\n              break;\n            case 'right':\n              offset.left =  position.left + position.width - actualWidth;\n            }\n          } else if(split[0] === 'left' || split[0] === 'right') {\n            switch (split[1]) {\n            case 'top':\n              offset.top = position.top - actualHeight;\n              break;\n            case 'bottom':\n              offset.top = position.top + position.height;\n            }\n          }\n\n          return offset;\n        }\n\n        function applyPlacement(offset, placement) {\n          var tip = tipElement[0],\n              width = tip.offsetWidth,\n              height = tip.offsetHeight;\n\n          // manually read margins because getBoundingClientRect includes difference\n          var marginTop = parseInt(dimensions.css(tip, 'margin-top'), 10),\n              marginLeft = parseInt(dimensions.css(tip, 'margin-left'), 10);\n\n          // we must check for NaN for ie 8/9\n          if (isNaN(marginTop)) marginTop  = 0;\n          if (isNaN(marginLeft)) marginLeft = 0;\n\n          offset.top  = offset.top + marginTop;\n          offset.left = offset.left + marginLeft;\n\n          // dimensions setOffset doesn't round pixel values\n          // so we use setOffset directly with our own function\n          dimensions.setOffset(tip, angular.extend({\n            using: function (props) {\n              tipElement.css({\n                top: Math.round(props.top) + 'px',\n                left: Math.round(props.left) + 'px',\n                right: ''\n              });\n            }\n          }, offset), 0);\n\n          // check to see if placing tip in new offset caused the tip to resize itself\n          var actualWidth = tip.offsetWidth,\n              actualHeight = tip.offsetHeight;\n\n          if (placement === 'top' && actualHeight !== height) {\n            offset.top = offset.top + height - actualHeight;\n          }\n\n          // If it's an exotic placement, exit now instead of\n          // applying a delta and changing the arrow\n          if (/top-left|top-right|bottom-left|bottom-right/.test(placement)) return;\n\n          var delta = getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);\n\n          if (delta.left) {\n            offset.left += delta.left;\n          } else {\n            offset.top += delta.top;\n          }\n\n          dimensions.setOffset(tip, offset);\n\n          if (/top|right|bottom|left/.test(placement)) {\n            var isVertical = /top|bottom/.test(placement),\n                arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight,\n                arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';\n\n            replaceArrow(arrowDelta, tip[arrowOffsetPosition], isVertical);\n          }\n        }\n\n        function getViewportAdjustedDelta(placement, position, actualWidth, actualHeight) {\n          var delta = { top: 0, left: 0 },\n              $viewport = options.viewport && findElement(options.viewport.selector || options.viewport);\n\n          if (!$viewport) {\n           return delta;\n          }\n\n          var viewportPadding = options.viewport && options.viewport.padding || 0,\n              viewportDimensions = getPosition($viewport);\n\n          if (/right|left/.test(placement)) {\n            var topEdgeOffset    = position.top - viewportPadding - viewportDimensions.scroll,\n                bottomEdgeOffset = position.top + viewportPadding - viewportDimensions.scroll + actualHeight;\n            if (topEdgeOffset < viewportDimensions.top) { // top overflow\n              delta.top = viewportDimensions.top - topEdgeOffset;\n            } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow\n              delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;\n            }\n          } else {\n            var leftEdgeOffset  = position.left - viewportPadding,\n                rightEdgeOffset = position.left + viewportPadding + actualWidth;\n            if (leftEdgeOffset < viewportDimensions.left) { // left overflow\n              delta.left = viewportDimensions.left - leftEdgeOffset;\n            } else if (rightEdgeOffset > viewportDimensions.width) { // right overflow\n              delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;\n            }\n          }\n\n          return delta;\n        }\n\n        function replaceArrow(delta, dimension, isHorizontal) {\n          var $arrow = findElement('.tooltip-arrow, .arrow', tipElement[0]);\n\n          $arrow.css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')\n                .css(isHorizontal ? 'top' : 'left', '');\n        }\n\n        function destroyTipElement() {\n          // Cancel pending callbacks\n          clearTimeout(timeout);\n\n          if($tooltip.$isShown && tipElement !== null) {\n            if(options.autoClose) {\n              unbindAutoCloseEvents();\n            }\n\n            if(options.keyboard) {\n              unbindKeyboardEvents();\n            }\n          }\n\n          if(tipScope) {\n            tipScope.$destroy();\n            tipScope = null;\n          }\n\n          if(tipElement) {\n            if(!options.inlineTemplate) {\n              tipElement.remove();\n            }\n            tipElement = $tooltip.$element = null;\n          }\n        }\n\n        return $tooltip;\n\n      }\n\n      // Helper functions\n\n      function safeDigest(scope) {\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n      }\n\n      function findElement(query, element) {\n        return angular.element((element || document).querySelectorAll(query));\n      }\n\n      var fetchPromises = {};\n      function fetchTemplate(template) {\n        if(fetchPromises[template]) return fetchPromises[template];\n        return (fetchPromises[template] = $http.get(template, {cache: $templateCache}).then(function(res) {\n          return res.data;\n        }));\n      }\n\n      return TooltipFactory;\n\n    };\n\n  })\n\n  .directive('bsTooltip', function($window, $location, $sce, $tooltip, $$rAF) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'contentTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'backdropAnimation', 'type', 'customClass', 'id'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container'], function(key) {\n          if(angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key]))\n            options[key] = false;\n        });\n\n        // should not parse target attribute (anchor tag), only data-target #1454\n        var dataTarget = element.attr('data-target');\n        if(angular.isDefined(dataTarget)) {\n          if(falseValueRegExp.test(dataTarget))\n            options.target = false;\n          else\n            options.target = dataTarget;\n        }\n\n        // overwrite inherited title value when no value specified\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\n        if (!scope.hasOwnProperty('title')){\n          scope.title = '';\n        }\n\n        // Observe scope attributes for change\n        attr.$observe('title', function(newValue) {\n          if (angular.isDefined(newValue) || !scope.hasOwnProperty('title')) {\n            var oldValue = scope.title;\n            scope.title = $sce.trustAsHtml(newValue);\n            angular.isDefined(oldValue) && $$rAF(function() {\n              tooltip && tooltip.$applyPlacement();\n            });\n          }\n        });\n\n        // Support scope as an object\n        attr.bsTooltip && scope.$watch(attr.bsTooltip, function(newValue, oldValue) {\n          if(angular.isObject(newValue)) {\n            angular.extend(scope, newValue);\n          } else {\n            scope.title = newValue;\n          }\n          angular.isDefined(oldValue) && $$rAF(function() {\n            tooltip && tooltip.$applyPlacement();\n          });\n        }, true);\n\n        // Visibility binding support\n        attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {\n          if(!tooltip || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|,?(tooltip),?/i);\n          newValue === true ? tooltip.show() : tooltip.hide();\n        });\n\n        // Enabled binding support\n        attr.bsEnabled && scope.$watch(attr.bsEnabled, function(newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', attr.bsEnabled, newValue, oldValue);\n          if(!tooltip || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(tooltip),?/i);\n          newValue === false ? tooltip.setEnabled(false) : tooltip.setEnabled(true);\n        });\n\n        // Viewport support\n        attr.viewport && scope.$watch(attr.viewport, function (newValue) {\n          if(!tooltip || !angular.isDefined(newValue)) return;\n          tooltip.setViewport(newValue);\n        });\n\n        // Initialize popover\n        var tooltip = $tooltip(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if(tooltip) tooltip.destroy();\n          options = null;\n          tooltip = null;\n        });\n\n      }\n    };\n\n  });\n"],"sourceRoot":"/source/"}