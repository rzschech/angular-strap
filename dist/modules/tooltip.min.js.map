{"version":3,"sources":["modules/tooltip.js"],"names":["angular","target","provider","placement","this","defaults","templateUrl","template","titleTemplate","trigger","keyboard","html","show","title","type","delay","autoClose","bsEnabled","mouseDownPreventDefault","mouseDownStopPropagation","viewport","selector","padding","TooltipFactory","$get","options","inlineTemplate","$window","$rootScope","$bsCompiler","$q","$templateCache","$http","$animate","$sce","dimensions","$$rAF","$timeout","element","config","clearTimeout","hoverState","prefixEvent","$tooltip","hide","isFunction","onShow","leaveAnimateCallback","scope","$emit","onHide","tipElement","css","_tipToHide","_blur","blur","toggle","evt","destroyTipElement","triggers","nodeName","split","on","isTouch","enter","unbindTriggerEvents","length","$onFocusElementMouseDown","off","i","bindKeyboardEvents","$onKeyUp","unbindKeyboardEvents","_autoCloseEventsBinded","bindAutoCloseEvents","$onFocusKeyUp","node","$body","event","parentNode","getPosition","$element","el","elRect","p","rect","width","height","top","left","extend","offset","scroll","outerDims","isBody","document","documentElement","scrollTop","body","prop","clientWidth","innerHeight","position","actualWidth","actualHeight","marginLeft","isNaN","setOffset","using","parseInt","props","right","marginTop","tip","offsetHeight","getViewportAdjustedDelta","delta","offsetWidth","isVertical","arrowDelta","replaceArrow","arrowOffsetPosition","viewportDimensions","$viewport","topEdgeOffset","bottomEdgeOffset","viewportPadding","test","leftEdgeOffset","rightEdgeOffset","dimension","isHorizontal","findElement","$arrow","unbindAutoCloseEvents","timeout","$isShown","tipScope","safeDigest","$options","promise","$promise","deferred","isString","compile","$scope","$new","toLowerCase","$id","attr","map","parseFloat","trustAsHtml","$setEnabled","$$postDigest","id","$hide","setEnabled","isEnabled","compileData","then","data","tipContainer","init","container","bindTriggerEvents","isElement","destroy","focus","$destroy","isDefined","onBeforeShow","after","parent","lastChild","display","visibility","link","clonedElement","prepend","addClass","prefixClass","customClass","$applyPlacement","enterAnimateCallback","version","minor","onBeforeHide","leave","preventDefault","autoPlace","autoToken","elementPosition","tipWidth","tipHeight","replace","viewportPosition","originalPlacement","bottomOverlap","bottom","topOverlap","rightOverlap","leftOverlap","hasClass","removeClass","indexOf","tipPosition","getCalculatedOffset","applyPlacement","stopPropagation","forEach","directive","$root","$$phase","$digest","restrict","query","querySelectorAll","isNative","defer","resolve","tooltip","transclusion","falseValueRegExp","key","$eval","bsKey","dataTarget","slice","hasOwnProperty","oldValue","$observe","newValue","bsTooltip","bsShow","$watch","match","setViewport","$on"],"mappings":"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","file":"modules/tooltip.min.js","sourcesContent":["'use strict';\n\nangular.module('mgcrea.ngStrap.tooltip', ['mgcrea.ngStrap.core', 'mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$tooltip', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      customClass: '',\n      prefixClass: 'tooltip',\n      prefixEvent: 'tooltip',\n      container: false,\n      target: false,\n      placement: 'top',\n      templateUrl: 'tooltip/tooltip.tpl.html',\n      template: '',\n      titleTemplate: false,\n      trigger: 'hover focus',\n      keyboard: false,\n      html: false,\n      show: false,\n      title: '',\n      type: '',\n      delay: 0,\n      autoClose: false,\n      bsEnabled: true,\n      mouseDownPreventDefault: true,\n      mouseDownStopPropagation: true,\n      viewport: {\n        selector: 'body',\n        padding: 0\n      }\n    };\n\n    this.$get = function ($window, $rootScope, $bsCompiler, $q, $templateCache, $http, $animate, $sce, dimensions, $$rAF, $timeout) {\n\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n      var $body = angular.element($window.document);\n\n      function TooltipFactory (element, config) {\n\n        var $tooltip = {};\n\n        // Common vars\n        var options = $tooltip.$options = angular.extend({}, defaults, config);\n        if (options.inlineTemplate) {\n          var deferred = $q.defer();\n          deferred.resolve();\n          $tooltip.$promise = deferred.promise;\n        }\n        else {\n          $tooltip.$promise = $bsCompiler.compile(options);\n        }\n        var promise = $tooltip.$promise;\n\n        var scope = $tooltip.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n\n        var nodeName = element[0].nodeName.toLowerCase();\n        if (options.delay && angular.isString(options.delay)) {\n          var split = options.delay.split(',').map(parseFloat);\n          options.delay = split.length > 1 ? {show: split[0], hide: split[1]} : split[0];\n        }\n\n        // Store $id to identify the triggering element in events\n        // give priority to options.id, otherwise, try to use\n        // element id if defined\n        $tooltip.$id = options.id || element.attr('id') || '';\n\n        // Support scope as string options\n        if (options.title) {\n          scope.title = $sce.trustAsHtml(options.title);\n        }\n\n        // Provide scope helpers\n        scope.$setEnabled = function (isEnabled) {\n          scope.$$postDigest(function () {\n            $tooltip.setEnabled(isEnabled);\n          });\n        };\n        scope.$hide = function () {\n          scope.$$postDigest(function () {\n            $tooltip.hide();\n          });\n        };\n        scope.$show = function () {\n          scope.$$postDigest(function () {\n            $tooltip.show();\n          });\n        };\n        scope.$toggle = function () {\n          scope.$$postDigest(function () {\n            $tooltip.toggle();\n          });\n        };\n        // Publish isShown as a protected var on scope\n        $tooltip.$isShown = scope.$isShown = false;\n\n        // Private vars\n        var timeout;\n        var hoverState;\n\n        // Fetch, compile then initialize tooltip\n        var compileData;\n        var tipElement;\n        var tipContainer;\n        var tipScope;\n        promise.then(function (data) {\n          compileData = data;\n          $tooltip.init();\n        });\n\n        $tooltip.init = function () {\n\n          // Options: delay\n          if (options.delay && angular.isNumber(options.delay)) {\n            options.delay = {\n              show: options.delay,\n              hide: options.delay\n            };\n          }\n\n          // Replace trigger on touch devices ?\n          // if(isTouch && options.trigger === defaults.trigger) {\n          //   options.trigger.replace(/hover/g, 'click');\n          // }\n\n          // Options : container\n          if (options.container === 'self') {\n            tipContainer = element;\n          } else if (angular.isElement(options.container)) {\n            tipContainer = options.container;\n          } else if (options.container) {\n            tipContainer = findElement(options.container);\n          }\n\n          // Options: trigger\n          bindTriggerEvents();\n\n          // Options: target\n          if (options.target) {\n            options.target = angular.isElement(options.target) ? options.target : findElement(options.target);\n          }\n\n          // Options: inlineTemplate\n          if (options.inlineTemplate) {\n            options.inlineTemplate = angular.isElement(options.inlineTemplate) ? options.inlineTemplate : findElement(options.inlineTemplate, options.target && options.target[0]);\n          }\n\n          // Options: show\n          if (options.show) {\n            scope.$$postDigest(function () {\n              if (options.trigger === 'focus') {\n                element[0].focus();\n              } else {\n                $tooltip.show();\n              }\n            });\n          }\n\n        };\n\n        $tooltip.destroy = function () {\n\n          // Unbind events\n          unbindTriggerEvents();\n\n          // Remove element\n          destroyTipElement();\n\n          // Destroy scope\n          scope.$destroy();\n\n        };\n\n        $tooltip.enter = function () {\n\n          clearTimeout(timeout);\n          hoverState = 'in';\n          if (!options.delay || !options.delay.show) {\n            return $tooltip.show();\n          }\n\n          timeout = setTimeout(function () {\n            if (hoverState === 'in') $tooltip.show();\n          }, options.delay.show);\n\n        };\n\n        $tooltip.show = function () {\n          if (!options.bsEnabled || $tooltip.$isShown) return;\n\n          scope.$emit(options.prefixEvent + '.show.before', $tooltip);\n          if (angular.isDefined(options.onBeforeShow) && angular.isFunction(options.onBeforeShow)) {\n            options.onBeforeShow($tooltip);\n          }\n          var parent;\n          var after;\n          if (options.inlineTemplate) {\n            tipElement = $tooltip.$element = options.inlineTemplate;\n          }\n          else {\n            if (options.container) {\n              parent = tipContainer;\n              if (tipContainer[0].lastChild) {\n                after = angular.element(tipContainer[0].lastChild);\n              } else {\n                after = null;\n              }\n            } else {\n              parent = null;\n              after = element;\n            }\n\n\n            // Hide any existing tipElement\n            if (tipElement) destroyTipElement();\n            // Fetch a cloned element linked from template\n            tipScope = $tooltip.$scope.$new();\n            tipElement = $tooltip.$element = compileData.link(tipScope, function (clonedElement, scope) {});\n\n            // Set the initial positioning.  Make the tooltip invisible\n            // so IE doesn't try to focus on it off screen.\n            tipElement.css({top: '-9999px', left: '-9999px', right: 'auto', display: 'block', visibility: 'hidden'});\n          }\n\n          // Options: animation\n          if (options.animation) tipElement.addClass(options.animation);\n          // Options: type\n          if (options.type) tipElement.addClass(options.prefixClass + '-' + options.type);\n          // Options: custom classes\n          if (options.customClass) tipElement.addClass(options.customClass);\n\n          if (!options.inlineTemplate) {\n            // Append the element, without any animations.  If we append\n            // using $animate.enter, some of the animations cause the placement\n            // to be off due to the transforms.\n            if (after) {\n              after.after(tipElement);\n            } else {\n              parent.prepend(tipElement);\n            }\n          }\n\n          $tooltip.$isShown = scope.$isShown = true;\n          safeDigest(scope);\n\n          // Now, apply placement\n          $tooltip.$applyPlacement();\n\n          if (options.inlineTemplate) {\n            enterAnimateCallback();\n          }\n          else {\n            // Once placed, animate it.\n            // Support v1.2+ $animate\n            // https://github.com/angular/angular.js/issues/11713\n            if (angular.version.minor <= 2) {\n              $animate.enter(tipElement, parent, after, enterAnimateCallback);\n            } else {\n              $animate.enter(tipElement, parent, after).then(enterAnimateCallback);\n            }\n          }\n          safeDigest(scope);\n\n          $$rAF(function () {\n            // Once the tooltip is placed and the animation starts, make the tooltip visible\n            if (tipElement) tipElement.css({visibility: 'visible'});\n            $tooltip.$applyPlacement();\n\n            // Bind events\n            if (options.keyboard) {\n              if (options.trigger !== 'focus') {\n                $tooltip.focus();\n              }\n              bindKeyboardEvents();\n            }\n          });\n\n          if (options.autoClose) {\n            bindAutoCloseEvents();\n          }\n\n        };\n\n        function enterAnimateCallback () {\n          scope.$emit(options.prefixEvent + '.show', $tooltip);\n          if (angular.isDefined(options.onShow) && angular.isFunction(options.onShow)) {\n            options.onShow($tooltip);\n          }\n        }\n\n        $tooltip.leave = function () {\n\n          clearTimeout(timeout);\n          hoverState = 'out';\n          if (!options.delay || !options.delay.hide) {\n            return $tooltip.hide();\n          }\n          timeout = setTimeout(function () {\n            if (hoverState === 'out') {\n              $tooltip.hide();\n            }\n          }, options.delay.hide);\n\n        };\n\n        var _blur;\n        var _tipToHide;\n        $tooltip.hide = function (blur) {\n\n          if (!$tooltip.$isShown) return;\n          scope.$emit(options.prefixEvent + '.hide.before', $tooltip);\n          if (angular.isDefined(options.onBeforeHide) && angular.isFunction(options.onBeforeHide)) {\n            options.onBeforeHide($tooltip);\n          }\n\n          // store blur value for leaveAnimateCallback to use\n          _blur = blur;\n\n          // store current tipElement reference to use\n          // in leaveAnimateCallback\n          _tipToHide = tipElement;\n\n          if (options.inlineTemplate) {\n            leaveAnimateCallback();\n          }\n          else {\n            // Support v1.2+ $animate\n            // https://github.com/angular/angular.js/issues/11713\n            if (angular.version.minor <= 2) {\n              $animate.leave(tipElement, leaveAnimateCallback);\n            } else {\n              $animate.leave(tipElement).then(leaveAnimateCallback);\n            }\n          }\n\n          $tooltip.$isShown = scope.$isShown = false;\n          safeDigest(scope);\n\n          // Unbind events\n          if (options.keyboard && tipElement !== null) {\n            unbindKeyboardEvents();\n          }\n\n          if (options.autoClose && tipElement !== null) {\n            unbindAutoCloseEvents();\n          }\n        };\n\n        function leaveAnimateCallback () {\n          scope.$emit(options.prefixEvent + '.hide', $tooltip);\n          if (angular.isDefined(options.onHide) && angular.isFunction(options.onHide)) {\n            options.onHide($tooltip);\n          }\n\n          // check if current tipElement still references\n          // the same element when hide was called\n          if (tipElement === _tipToHide) {\n            // Allow to blur the input when hidden, like when pressing enter key\n            if (_blur && options.trigger === 'focus') {\n              return element[0].blur();\n            }\n\n            if (options.inlineTemplate) {\n              tipElement.css({display: '', visibility: ''});\n            }\n\n            // clean up child scopes\n            destroyTipElement();\n          }\n        }\n\n        $tooltip.toggle = function (evt) {\n          if (evt) { evt.preventDefault(); }\n          if ($tooltip.$isShown) {\n            $tooltip.leave();\n          } else {\n            $tooltip.enter();\n          }\n        };\n\n        $tooltip.focus = function () {\n          tipElement[0].focus();\n        };\n\n        $tooltip.setEnabled = function (isEnabled) {\n          options.bsEnabled = isEnabled;\n        };\n\n        $tooltip.setViewport = function (viewport) {\n          options.viewport = viewport;\n        };\n\n        // Protected methods\n\n        $tooltip.$applyPlacement = function () {\n          if (!tipElement) return;\n\n          // Determine if we're doing an auto or normal placement\n          var placement = options.placement;\n          var autoToken = /\\s?auto?\\s?/i;\n          var autoPlace = autoToken.test(placement);\n\n          if (autoPlace) {\n            placement = placement.replace(autoToken, '') || defaults.placement;\n          }\n\n          // Need to add the position class before we get\n          // the offsets\n          tipElement.addClass(options.placement);\n\n          // Get the position of the target element\n          // and the height and width of the tooltip so we can center it.\n          var elementPosition = getPosition();\n          var tipWidth = tipElement.prop('offsetWidth');\n          var tipHeight = tipElement.prop('offsetHeight');\n\n          // Refresh viewport position\n          $tooltip.$viewport = options.viewport && findElement(options.viewport.selector || options.viewport);\n\n          // If we're auto placing, we need to check the positioning\n          if (autoPlace) {\n            var originalPlacement = placement;\n            var viewportPosition = getPosition($tooltip.$viewport);\n\n            // Determine if the vertical placement\n            var bottom = /bottom/.test(originalPlacement);\n            var top = /top/.test(originalPlacement);\n\n            if (bottom || top) {\n              var bottomOverlap = elementPosition.bottom - viewportPosition.bottom + tipHeight;\n              var topOverlap = viewportPosition.top - elementPosition.top + tipHeight;\n              if (bottom && bottomOverlap > 0 || top && topOverlap > 0) {\n                if (bottomOverlap < topOverlap) {\n                  if (top) {\n                    placement = originalPlacement.replace('top', 'bottom');\n                  }\n                }\n                else {\n                  if (bottom) {\n                    placement = originalPlacement.replace('bottom', 'top');\n                  }\n                }\n              }\n            }\n\n            // Determine the horizontal placement\n            // The exotic placements of left and right are opposite of the standard placements.  Their arrows are put on the left/right\n            // and flow in the opposite direction of their placement.\n            var right = originalPlacement === 'right' || originalPlacement === 'bottom-left' || originalPlacement === 'top-left';\n            var left = originalPlacement === 'left' || originalPlacement === 'bottom-right' || originalPlacement === 'top-right';\n            if (right || left) {\n              var rightOverlap = elementPosition.right - viewportPosition.right + tipWidth;\n              var leftOverlap = viewportPosition.left - elementPosition.left + tipWidth;\n              if (right && rightOverlap > 0 || left && leftOverlap > 0) {\n                if (rightOverlap < leftOverlap) {\n                  if (left) {\n                    placement = originalPlacement === 'left' ? 'right' : placement.replace('right', 'left');\n                  }\n                }\n                else {\n                  if (right) {\n                    placement = originalPlacement === 'right' ? 'left' : placement.replace('left', 'right');\n                  }\n                }\n              }\n            }\n\n            tipElement.removeClass(originalPlacement).addClass(placement);\n          }\n\n          if (options.target && (options.target.hasClass('dropdown') || options.target.hasClass('dropup'))) {\n            if (placement.indexOf('top') >= 0) {\n              options.target.removeClass('dropdown').addClass('dropup');\n            }\n            else {\n              options.target.removeClass('dropup').addClass('dropdown');\n            }\n\n            if (tipElement.hasClass('dropdown-menu')) {\n              if (placement.indexOf('left') >= 0) {\n                tipElement.removeClass('dropdown-menu-right');\n              }\n              else {\n                tipElement.addClass('dropdown-menu-right');\n              }\n            }\n          }\n          else {\n            // Get the tooltip's top and left coordinates to center it with this directive.\n            var tipPosition = getCalculatedOffset(placement, elementPosition, tipWidth, tipHeight);\n            applyPlacement(tipPosition, placement);\n          }\n        };\n\n        $tooltip.$onKeyUp = function (evt) {\n          if (evt.which === 27 && $tooltip.$isShown) {\n            $tooltip.hide();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusKeyUp = function (evt) {\n          if (evt.which === 27) {\n            element[0].blur();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusElementMouseDown = function (evt) {\n          if (options.mouseDownPreventDefault) { evt.preventDefault(); }\n          if (options.mouseDownStopPropagation) { evt.stopPropagation(); }\n          // Some browsers do not auto-focus buttons (eg. Safari)\n          if ($tooltip.$isShown) {\n            element[0].blur();\n          } else {\n            element[0].focus();\n          }\n        };\n\n        // bind/unbind events\n        function bindTriggerEvents () {\n          var triggers = options.trigger.split(' ');\n          angular.forEach(triggers, function (trigger) {\n            if (trigger === 'click' || trigger === 'contextmenu') {\n              element.on(trigger, $tooltip.toggle);\n            } else if (trigger !== 'manual') {\n              element.on(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.on(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              if (nodeName === 'button' && trigger !== 'hover') {\n                element.on(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n              }\n            }\n          });\n        }\n\n        function unbindTriggerEvents () {\n          var triggers = options.trigger.split(' ');\n          for (var i = triggers.length; i--;) {\n            var trigger = triggers[i];\n            if (trigger === 'click' || trigger === 'contextmenu') {\n              element.off(trigger, $tooltip.toggle);\n            } else if (trigger !== 'manual') {\n              element.off(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.off(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              if (nodeName === 'button' && trigger !== 'hover') {\n                element.off(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n              }\n            }\n          }\n        }\n\n        function bindKeyboardEvents () {\n          if (options.trigger !== 'focus') {\n            tipElement.on('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.on('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        function unbindKeyboardEvents () {\n          if (options.trigger !== 'focus') {\n            tipElement.off('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.off('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        var _autoCloseEventsBinded = false;\n        function bindAutoCloseEvents () {\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function () {\n            // Hide when clicking outside tooltip\n            $body.on('click', hideIfNotChildEvent);\n\n            _autoCloseEventsBinded = true;\n          }, 0, false);\n        }\n\n        function unbindAutoCloseEvents () {\n          if (_autoCloseEventsBinded) {\n            $body.off('click', hideIfNotChildEvent);\n            _autoCloseEventsBinded = false;\n          }\n        }\n\n        function hideIfNotChildEvent (event) {\n          var node = event.target;\n          while (node) {\n            if (node === tipElement[0]) {\n              return;\n            }\n            if (node === $body[0]) {\n              $tooltip.hide();\n              return;\n            }\n            node = node.parentNode;\n          }\n        }\n\n        // Private methods\n\n        function getPosition ($element) {\n          $element = $element || (options.target || element);\n\n          var el = $element[0];\n          var isBody = el.tagName === 'BODY';\n\n          var elRect = el.getBoundingClientRect();\n          var rect = {};\n\n          // IE8 has issues with angular.extend and using elRect directly.\n          // By coping the values of elRect into a new object, we can continue to use extend\n          /* eslint-disable guard-for-in */\n          for (var p in elRect) { // eslint-disable-line\n            // DO NOT use hasOwnProperty when inspecting the return of getBoundingClientRect.\n            rect[p] = elRect[p];\n          }\n          /* eslint-enable guard-for-in */\n\n          if (rect.width === null) {\n            // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\n            rect = angular.extend({}, rect, {width: elRect.right - elRect.left, height: elRect.bottom - elRect.top});\n          }\n          var elOffset = isBody ? {top: 0, left: 0} : dimensions.offset(el);\n          var scroll = {scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.prop('scrollTop') || 0};\n          var outerDims = isBody ? {width: document.documentElement.clientWidth, height: $window.innerHeight} : null;\n\n          return angular.extend({}, rect, scroll, outerDims, elOffset);\n        }\n\n        function getCalculatedOffset (placement, position, actualWidth, actualHeight) {\n          var offset;\n          var split = placement.split('-');\n\n          switch (split[0]) {\n            case 'right':\n              offset = {\n                top: position.top + position.height / 2 - actualHeight / 2,\n                left: position.left + position.width\n              };\n              break;\n            case 'bottom':\n              offset = {\n                top: position.top + position.height,\n                left: position.left + position.width / 2 - actualWidth / 2\n              };\n              break;\n            case 'left':\n              offset = {\n                top: position.top + position.height / 2 - actualHeight / 2,\n                left: position.left - actualWidth\n              };\n              break;\n            default:\n              offset = {\n                top: position.top - actualHeight,\n                left: position.left + position.width / 2 - actualWidth / 2\n              };\n              break;\n          }\n\n          if (!split[1]) {\n            return offset;\n          }\n\n          // Add support for corners @todo css\n          if (split[0] === 'top' || split[0] === 'bottom') {\n            switch (split[1]) {\n              case 'left':\n                offset.left = position.left;\n                break;\n              case 'right':\n                offset.left = position.left + position.width - actualWidth;\n                break;\n              default:\n                break;\n            }\n          } else if (split[0] === 'left' || split[0] === 'right') {\n            switch (split[1]) {\n              case 'top':\n                offset.top = position.top - actualHeight + position.height;\n                break;\n              case 'bottom':\n                offset.top = position.top;\n                break;\n              default:\n                break;\n            }\n          }\n\n          return offset;\n        }\n\n        function applyPlacement (offset, placement) {\n          var tip = tipElement[0];\n          var width = tip.offsetWidth;\n          var height = tip.offsetHeight;\n\n          // manually read margins because getBoundingClientRect includes difference\n          var marginTop = parseInt(dimensions.css(tip, 'margin-top'), 10);\n          var marginLeft = parseInt(dimensions.css(tip, 'margin-left'), 10);\n\n          // we must check for NaN for ie 8/9\n          if (isNaN(marginTop)) marginTop = 0;\n          if (isNaN(marginLeft)) marginLeft = 0;\n\n          offset.top = offset.top + marginTop;\n          offset.left = offset.left + marginLeft;\n\n          // dimensions setOffset doesn't round pixel values\n          // so we use setOffset directly with our own function\n          dimensions.setOffset(tip, angular.extend({\n            using: function (props) {\n              tipElement.css({\n                top: Math.round(props.top) + 'px',\n                left: Math.round(props.left) + 'px',\n                right: ''\n              });\n            }\n          }, offset), 0);\n\n          // check to see if placing tip in new offset caused the tip to resize itself\n          var actualWidth = tip.offsetWidth;\n          var actualHeight = tip.offsetHeight;\n\n          if (placement === 'top' && actualHeight !== height) {\n            offset.top = offset.top + height - actualHeight;\n          }\n\n          // If it's an exotic placement, exit now instead of\n          // applying a delta and changing the arrow\n          if (/top-left|top-right|bottom-left|bottom-right/.test(placement)) return;\n\n          var delta = getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);\n\n          if (delta.left) {\n            offset.left += delta.left;\n          } else {\n            offset.top += delta.top;\n          }\n\n          dimensions.setOffset(tip, offset);\n\n          if (/top|right|bottom|left/.test(placement)) {\n            var isVertical = /top|bottom/.test(placement);\n            var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight;\n            var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';\n\n            replaceArrow(arrowDelta, tip[arrowOffsetPosition], isVertical);\n          }\n        }\n\n        // @source https://github.com/twbs/bootstrap/blob/v3.3.5/js/tooltip.js#L380\n        function getViewportAdjustedDelta (placement, position, actualWidth, actualHeight) {\n          var delta = {top: 0, left: 0};\n          if (!$tooltip.$viewport) return delta;\n\n          var viewportPadding = options.viewport && options.viewport.padding || 0;\n          var viewportDimensions = getPosition($tooltip.$viewport);\n\n          if (/right|left/.test(placement)) {\n            var topEdgeOffset = position.top - viewportPadding - viewportDimensions.scroll;\n            var bottomEdgeOffset = position.top + viewportPadding - viewportDimensions.scroll + actualHeight;\n            if (topEdgeOffset < viewportDimensions.top) { // top overflow\n              delta.top = viewportDimensions.top - topEdgeOffset;\n            } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow\n              delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;\n            }\n          } else {\n            var leftEdgeOffset = position.left - viewportPadding;\n            var rightEdgeOffset = position.left + viewportPadding + actualWidth;\n            if (leftEdgeOffset < viewportDimensions.left) { // left overflow\n              delta.left = viewportDimensions.left - leftEdgeOffset;\n            } else if (rightEdgeOffset > viewportDimensions.right) { // right overflow\n              delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;\n            }\n          }\n\n          return delta;\n        }\n\n        function replaceArrow (delta, dimension, isHorizontal) {\n          var $arrow = findElement('.tooltip-arrow, .arrow', tipElement[0]);\n\n          $arrow.css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')\n                .css(isHorizontal ? 'top' : 'left', '');\n        }\n\n        function destroyTipElement () {\n          // Cancel pending callbacks\n          clearTimeout(timeout);\n\n          if ($tooltip.$isShown && tipElement !== null) {\n            if (options.autoClose) {\n              unbindAutoCloseEvents();\n            }\n\n            if (options.keyboard) {\n              unbindKeyboardEvents();\n            }\n          }\n\n          if (tipScope) {\n            tipScope.$destroy();\n            tipScope = null;\n          }\n\n          if (tipElement) {\n            if (!options.inlineTemplate) {\n              tipElement.remove();\n            }\n            tipElement = $tooltip.$element = null;\n          }\n        }\n\n        return $tooltip;\n\n      }\n\n      // Helper functions\n\n      function safeDigest (scope) {\n        /* eslint-disable no-unused-expressions */\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n        /* eslint-enable no-unused-expressions */\n      }\n\n      function findElement (query, element) {\n        return angular.element((element || document).querySelectorAll(query));\n      }\n\n      return TooltipFactory;\n\n    };\n\n  })\n\n  .directive('bsTooltip', function ($window, $location, $sce, $parse, $tooltip, $$rAF) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink (scope, element, attr, transclusion) {\n\n        var tooltip;\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'titleTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'backdropAnimation', 'type', 'customClass', 'id'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\n            options[key] = false;\n          }\n        });\n\n        // bind functions from the attrs to the show and hide events\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n          if (angular.isDefined(attr[bsKey])) {\n            options[key] = scope.$eval(attr[bsKey]);\n          }\n        });\n\n        // should not parse target attribute (anchor tag), only data-target #1454\n        var dataTarget = element.attr('data-target');\n        if (angular.isDefined(dataTarget)) {\n          if (falseValueRegExp.test(dataTarget)) {\n            options.target = false;\n          } else {\n            options.target = dataTarget;\n          }\n        }\n\n        // overwrite inherited title value when no value specified\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\n        if (!scope.hasOwnProperty('title')) {\n          scope.title = '';\n        }\n\n        // Observe scope attributes for change\n        attr.$observe('title', function (newValue) {\n          if (angular.isDefined(newValue) || !scope.hasOwnProperty('title')) {\n            var oldValue = scope.title;\n            scope.title = $sce.trustAsHtml(newValue);\n            if (angular.isDefined(oldValue)) {\n              $$rAF(function () {\n                if (tooltip) tooltip.$applyPlacement();\n              });\n            }\n          }\n        });\n\n        attr.$observe('disabled', function (newValue) {\n          if (newValue && tooltip.$isShown) {\n            tooltip.hide();\n          }\n        });\n\n        // Support scope as an object\n        if (attr.bsTooltip) {\n          scope.$watch(attr.bsTooltip, function (newValue, oldValue) {\n            if (angular.isObject(newValue)) {\n              angular.extend(scope, newValue);\n            } else {\n              scope.title = newValue;\n            }\n            if (angular.isDefined(oldValue)) {\n              $$rAF(function () {\n                if (tooltip) tooltip.$applyPlacement();\n              });\n            }\n          }, true);\n        }\n\n        // Visibility binding support\n        if (attr.bsShow) {\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\n            if (!tooltip || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(tooltip),?/i);\n            if (newValue === true) {\n              tooltip.show();\n            } else {\n              tooltip.hide();\n            }\n          });\n        }\n\n        // Enabled binding support\n        if (attr.bsEnabled) {\n          scope.$watch(attr.bsEnabled, function (newValue, oldValue) {\n            // console.warn('scope.$watch(%s)', attr.bsEnabled, newValue, oldValue);\n            if (!tooltip || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(tooltip),?/i);\n            if (newValue === false) {\n              tooltip.setEnabled(false);\n            } else {\n              tooltip.setEnabled(true);\n            }\n          });\n        }\n\n        // Viewport support\n        if (attr.viewport) {\n          scope.$watch(attr.viewport, function (newValue) {\n            if (!tooltip || !angular.isDefined(newValue)) return;\n            tooltip.setViewport(newValue);\n          });\n        }\n\n        // Initialize popover\n        tooltip = $tooltip(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (tooltip) tooltip.destroy();\n          options = null;\n          tooltip = null;\n        });\n\n      }\n    };\n\n  });\n"],"sourceRoot":"/source/"}